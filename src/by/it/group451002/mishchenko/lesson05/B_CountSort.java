package by.it.group451002.mishchenko.lesson05;

import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.Scanner;

/*
Первая строка содержит число 1<=n<=10000, вторая - n натуральных чисел, не превышающих 10.
Выведите упорядоченную по неубыванию последовательность этих чисел.

При сортировке реализуйте метод со сложностью O(n)

Пример: https://karussell.wordpress.com/2010/03/01/fast-integer-sorting-algorithm-on/
Вольный перевод: http://programador.ru/sorting-positive-int-linear-time/
*/


public class B_CountSort {

    public static void main(String[] args) throws FileNotFoundException {
        // Получаем InputStream для файла dataB.txt из ресурсов текущего пакета
        InputStream stream = B_CountSort.class.getResourceAsStream("dataB.txt");

        // Создаем экземпляр класса для вызова нестатического метода countSort
        B_CountSort instance = new B_CountSort();

        // Вызываем метод сортировки и получаем отсортированный массив
        int[] result = instance.countSort(stream);

        // Выводим элементы отсортированного массива в одной строке через пробел
        for (int number : result) {
            System.out.print(number + " ");
        }
    }

    /**
     * Метод сортирует массив натуральных чисел, считанных из переданного InputStream,
     * используя алгоритм сортировки подсчётом, который работает за O(n).
     *
     * @param stream InputStream, содержащий входные данные: сначала число n, затем n чисел.
     * @return Массив отсортированных чисел.
     * @throws FileNotFoundException Если входной поток не найден.
     */
    int[] countSort(InputStream stream) throws FileNotFoundException {
        // Создаем Scanner для чтения из входного потока
        Scanner scanner = new Scanner(stream);

        //!!!!!!!!!!!!!!!!!!!!!!!!!     НАЧАЛО ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!

        // Считываем размер массива (количество чисел)
        int n = scanner.nextInt();

        // Создаем массив для хранения исходных чисел
        int[] points = new int[n];

        // Считываем n натуральных чисел из входного потока и сохраняем их в массив
        for (int i = 0; i < n; i++) {
            points[i] = scanner.nextInt();
        }

        /*
           Для сортировки подсчётом необходимо понять, в каком диапазоне лежат входные значения.
           Согласно условию задачи, числа не превышают 10. Допустим, что минимальное число равно 0 или 1.
           Для удобства создадим массив подсчёта "count" размера maxVal+1, чтобы индексы совпадали с числами.
        */
        int maxVal = 10;                   // Максимальное возможное значение из входных данных
        int[] count = new int[maxVal + 1];   // Массив для подсчёта вхождений чисел от 0 до 10

        // Проходим по исходному массиву и подсчитываем, сколько раз встречается каждое число.
        for (int i = 0; i < n; i++) {
            int currentNumber = points[i]; // Выбираем текущее число
            // Увеличиваем счетчик для данного числа.
            count[currentNumber]++;
        }

        /*
           Теперь нам нужно восстановить отсортированный массив,
           используя массив count. Принцип заключается в следующем:
           - Проходим по всем возможным числам от 0 до maxVal.
           - Для каждого числа value, добавляем его в результирующий массив столько раз,
             сколько оно встречалось (значение count[value]).
           Таким образом, получится отсортированный по неубыванию массив.
        */
        int index = 0; // Индекс для записи в исходный массив points (будем перезаписывать его)
        // Проходим в порядке от наименьшего числа к наибольшему
        for (int value = 0; value <= maxVal; value++) {
            // Пока значение count[value] положительно, добавляем число value в массив
            while (count[value] > 0) {
                points[index] = value;  // Записываем число в результирующий массив
                index++;                // Переходим к следующей позиции в массиве
                count[value]--;         // Уменьшаем счетчик, так как одно вхождение обработано
            }
        }

        //!!!!!!!!!!!!!!!!!!!!!!!!!     КОНЕЦ ЗАДАЧИ     !!!!!!!!!!!!!!!!!!!!!!!!!

        // Возвращаем отсортированный массив
        return points;
    }
}

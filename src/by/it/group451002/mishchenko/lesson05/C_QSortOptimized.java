package by.it.group451002.mishchenko.lesson05;

import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.Scanner;

/*
Видеорегистраторы и площадь 2.
Условие то же что и в задаче А.

        По сравнению с задачей A доработайте алгоритм так, чтобы
        1) он оптимально использовал время и память:
            - за стек отвечает элиминация хвостовой рекурсии
            - за сам массив отрезков - сортировка на месте
            - рекурсивные вызовы должны проводиться на основе 3-разбиения

        2) при поиске подходящих отрезков для точки реализуйте метод бинарного поиска
        для первого отрезка решения, а затем найдите оставшуюся часть решения
        (т.е. отрезков, подходящих для точки, может быть много)

    Sample Input:
    2 3
    0 5
    7 10
    1 6 11
    Sample Output:
    1 0 0

*/





public class C_QSortOptimized {

    public static void main(String[] args) throws FileNotFoundException {
        // Чтение входных данных из файла dataC.txt, расположенного в том же пакете
        InputStream stream = C_QSortOptimized.class.getResourceAsStream("dataC.txt");
        C_QSortOptimized instance = new C_QSortOptimized();
        int[] result = instance.getAccessory2(stream);

        // Вывод результата: для каждой точки выводится число отрезков, которые её покрывают
        for (int index : result) {
            System.out.print(index + " ");
        }
    }

    /**
     * Метод решения задачи.
     * Сначала считываем данные: число отрезков, сами отрезки, число точек и сами точки.
     * Затем сортируем массив отрезков с использованием оптимизированной быстрой сортировки (3-разбиение).
     * Для каждого отрезка записываем отдельно начало и конец в массивы, сортируем массив с концами.
     * Для каждой точки считаем:
     *    - countStarts: число отрезков, у которых начало <= точке (бинарный поиск с upper bound)
     *    - countStops: число отрезков, у которых конец < точке (бинарный поиск с lower bound)
     * Разность countStarts - countStops даёт количество отрезков, которые покрывают точку.
     */
    int[] getAccessory2(InputStream stream) throws FileNotFoundException {
        // Подготовка к чтению входных данных посредством Scanner
        Scanner scanner = new Scanner(stream);

        // Читаем количество отрезков
        int n = scanner.nextInt();
        // Создаём массив объектов Segment длины n
        Segment[] segments = new Segment[n];

        // Читаем количество точек
        int m = scanner.nextInt();
        // Массив точек для запроса
        int[] points = new int[m];
        // Результирующий массив, где для каждой точки будет записано число отрезков, её покрывающих
        int[] result = new int[m];

        // Чтение описаний каждого отрезка: начало и конец
        for (int i = 0; i < n; i++) {
            int startVal = scanner.nextInt();
            int stopVal = scanner.nextInt();
            segments[i] = new Segment(startVal, stopVal);
        }
        // Чтение точек
        for (int i = 0; i < m; i++) {
            points[i] = scanner.nextInt();
        }

        // Сортируем массив отрезков по значению начала (и по концу, если начала равны)
        // Используем оптимизированную быструю сортировку с 3-разбиением и элиминацией хвостовой рекурсии
        quickSortSegments(segments, 0, n - 1);

        // Создадим два массива для хранения отдельно первых и вторых координат отрезков
        int[] starts = new int[n];
        int[] stops = new int[n];

        // Заполняем массивы на основе уже отсортированного массива segments.
        // Массив starts оказывается отсортирован по возрастанию, т.к. сегменты отсортированы по start.
        for (int i = 0; i < n; i++) {
            starts[i] = segments[i].start;
            stops[i] = segments[i].stop;
        }

        // Отсортируем массив stops по возрастанию. Для примитивных типов можно использовать
        // встроенный метод Arrays.sort, который сортирует массив "на месте".
        java.util.Arrays.sort(stops);

        // Для каждой точки с помощью бинарного поиска определяем число подходящих отрезков.
        // Отрезок покрывает точку 'p', если выполняется условие: start <= p <= stop.
        // Реализуем это через два бинарных поиска:
        // 1. upperBound для массива starts: находим первое место, где значение становится больше p.
        //    Это число даст количество отрезков, у которых start <= p.
        // 2. lowerBound для массива stops: находим первое место, где значение не меньше p.
        //    Это число соответствует количеству отрезков, у которых stop < p.
        // Разность этих двух чисел и даёт итоговое число отрезков, покрывающих точку.
        for (int i = 0; i < m; i++) {
            int p = points[i];
            // Число отрезков с началом <= p
            int countStarts = upperBound(starts, p);
            // Число отрезков с концом < p
            int countStops = lowerBound(stops, p);
            result[i] = countStarts - countStops;
        }

        // Возвращаем результаты для всех точек
        return result;
    }

    /**
     * Реализация быстрой сортировки (QuickSort) с трёх-разбиением.
     * Сортирует подмассив arr[low..high] класса Segment по значению 'start' (и при равенстве — по 'stop').
     *
     * Метод использует элиминацию хвостовой рекурсии для оптимизации использования стека.
     */
    private void quickSortSegments(Segment[] arr, int low, int high) {
        // Выполняем сортировку, пока существует неотсортированная часть массива.
        while (low < high) {
            // Выбираем опорный элемент. Здесь берем элемент с индексом low.
            Segment pivot = arr[low];
            // Инициализируем указатели:
            // lt (less than) — граница для элементов меньше опорного,
            // gt (greater than) — граница для элементов больше опорного,
            // i — текущий индекс, с которого начинаем проход.
            int lt = low;      // arr[low..lt-1] будут меньше pivot
            int gt = high;     // arr[gt+1..high] будут больше pivot
            int i = low + 1;   // arr[lt..i-1] будут равны pivot

            // Проходим по элементам от i до gt включительно
            while (i <= gt) {
                int cmp = arr[i].compareTo(pivot);
                if (cmp < 0) {
                    // Если текущий элемент меньше опорного,
                    // меняем его с элементом на позиции lt, затем сдвигаем lt и i вправо
                    swap(arr, lt, i);
                    lt++;
                    i++;
                } else if (cmp > 0) {
                    // Если текущий элемент больше опорного,
                    // меняем его с элементом на позиции gt и сдвигаем gt влево
                    swap(arr, i, gt);
                    gt--;
                    // Не увеличиваем i, так как элемент, пришедший на позицию i, нужно проверить
                } else {
                    // Если элемент равен опорному, просто переходим к следующему элементу
                    i++;
                }
            }
            // На этом этапе:
            // - элементы в диапазоне [low, lt-1] меньше опорного,
            // - элементы в диапазоне [lt, gt] равны опорному,
            // - элементы в диапазоне [gt+1, high] больше опорного.

            // Для элиминации хвостовой рекурсии выбираем для рекурсивной сортировки меньший из двух отрезков.
            if ((lt - low) < (high - gt)) {
                // Рекурсивно сортируем левую часть массива
                quickSortSegments(arr, low, lt - 1);
                // Затем сдвигаем границу для сортировки правой части, используя итеративное решение
                low = gt + 1;
            } else {
                // Рекурсивно сортируем правую часть массива
                quickSortSegments(arr, gt + 1, high);
                // Затем сдвигаем границу для сортировки левой части
                high = lt - 1;
            }
        } // Когда low >= high, отрезок уже отсортирован
    }

    /**
     * Метод для обмена элементов в массиве.
     * Меняет местами элементы с индексами i и j в массиве arr.
     */
    private void swap(Segment[] arr, int i, int j) {
        Segment temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    /**
     * Реализация бинарного поиска для определения upper bound.
     * Возвращает количество элементов в массиве arr, которые меньше или равны ключу key.
     * Другими словами, возвращает индекс первого элемента, большего ключа.
     *
     * Пример: если arr = [1, 3, 3, 5] и key = 3, функция вернёт 3,
     * так как элементы с индексами 0, 1, 2 (значения 1, 3, 3) удовлетворяют условию arr[i] <= 3.
     */
    private int upperBound(int[] arr, int key) {
        int low = 0;
        int high = arr.length;
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (arr[mid] <= key) {
                // Если arr[mid] удовлетворяет условию, продолжаем поиск в правой половине
                low = mid + 1;
            } else {
                // Если arr[mid] больше key, сужаем правую границу поиска
                high = mid;
            }
        }
        // В итоге low и high указывают на первую позицию, где arr[i] > key
        return low;
    }

    /**
     * Реализация бинарного поиска для определения lower bound.
     * Возвращает количество элементов в массиве arr, которые строго меньше ключа key.
     * Иначе говоря, находит первую позицию, где значение не меньше key.
     *
     * Пример: если arr = [1, 3, 3, 5] и key = 3, функция вернёт 1,
     * так как только элемент с индексом 0 (значение 1) строго меньше 3.
     */
    private int lowerBound(int[] arr, int key) {
        int low = 0;
        int high = arr.length;
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (arr[mid] < key) {
                // Продолжаем поиск в правой части, если arr[mid] меньше key
                low = mid + 1;
            } else {
                // Иначе сужаем область поиска
                high = mid;
            }
        }
        // Возвращаем индекс первого элемента, который не меньше key
        return low;
    }

    /**
     * Внутренний класс Segment представляет отрезок с начальной и конечной точками.
     */
    private class Segment implements Comparable {
        int start; // начало отрезка
        int stop;  // конец отрезка (включительно)

        /**
         * Конструктор, задающий начало и конец отрезка.
         *
         * @param start начало отрезка
         * @param stop  конец отрезка
         */
        Segment(int start, int stop) {
            this.start = start;
            this.stop = stop;
        }

        /**
         * Переопределение метода compareTo для реализации компаратора.
         * Сначала сравниваются отрезки по их началу (start).
         * Если начала равны, сравниваются по концу (stop).
         * Это необходимо для корректного порядка сортировки, который потом используется
         * при бинарном поиске подходящих отрезков для каждой точки.
         */
        @Override
        public int compareTo(Object o) {
            Segment other = (Segment) o;
            // Сравнение по началу отрезка
            if (this.start != other.start) {
                return this.start - other.start;
            }
            // Если начала равны, сравнение по концу отрезка
            return this.stop - other.stop;
        }
    }
}
